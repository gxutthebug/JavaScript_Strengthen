
闭包是一种函数现象

我们可以利用闭包：
①实现模块变量私有化

②实现纯函数调用的信息存储
一个函数想要利用一些外部变量 ， 想要缓存每一次函数执行的结果,或每一次执行传入的参数  (实现一些结果或者实参上的累积)
但是你又不能直接利用外部变量这样就不是纯函数了 。所以我们想到了利用闭包来给函数制造 “假的外部变量”。
对于 函数内return函数的闭包结构，你完全可以把内层函数访问的外层函数中的 “外层变量” 看做 “全局变量”！


闭包的两大应用： ① 模块化   ②柯里化





柯里化（Currying）是一种编程思想，函数执行产生一个闭包，把一些信息预先存储起来，目的是供下级上下文使用。
这样预先存储和处理的思想，就叫做柯里化的编程思想。

 本质是利用闭包实现了一个函数加工(柯里化)厂

函数加工厂 =====>  function  工厂名  (  要加工的函数a  ,  后续可以传一些累积变量 )  {
                             
                                                      这里可以定义一些累积变量      
   
                                               return  function ( ...arg ) {    //  返回加工后的函数（也可以使得内部逻辑函数的传参保持）纯净
                                                         处理x
                                                         处理y
                                                         调用要加工的函数a                        
                                                                        }
                                              }


当你想要:

 固定函数的某些参数  =====> 把要固定的参数与对应函数传入柯里化函数预存

 使一个函数的前后执行产生关联(累积/统计)    =====>  传入要柯里化的函数 ， 外层定义累积变量

 使多个函数的调用结果相互传递  =====>  传入要聚合的几个函数，内层reduce

 防抖 / 节流   =====>  主要是利用科里化 , 实现函数的节流 防抖加工，因为加工函数名 与延迟秒数在工厂函数内传入，
使得内部的逻辑函数的传参依然能保持纯净
